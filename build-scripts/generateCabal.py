#!/usr/bin/python
import sys
sys.path.append('../python_modules/')

import json
import logging

from optparse import OptionGroup

import appUtils

def usageString():
    return '%prog <json config path> <output path for cabal file>'

def versionString():
    return '%prog: 1.0'

# returns the option to add the relative path to search for shared directories on unix
def unixRPathOpt():
    return '-optl-Wl,-rpath,$ORIGIN'

def appSetOpts(parser):
    
    cabalOptions = OptionGroup(
        parser, 
        'Cabal Option Options')

    cabalOptions.add_option('--extra-libraries', type='string', dest='extraLibraries', default='',
        help='add additional libraries, colon delimited', 
        metavar='LIBRARIES')

    cabalOptions.add_option('--extra-lib-dirs', type='string', dest='extraLibDirs', default='',
        help='add additional dirs to search for libs, colon delimited', 
        metavar='LIBRARIES')

    cabalOptions.add_option('--ghc-options', type='string', dest='ghcOptions', default='',
        help='additional options to pass to ghc', 
        metavar='OPTS')

    cabalOptions.add_option('--unix', action='store_true', dest='unixmode', default=False,
        help='Adds additional options etc... for UNIX systems')

    cabalOptions.add_option('--release', action='store_true', dest='release', default=False,
        help='Adds optimisation options for release builds')

    cabalOptions.add_option('--profiling', action='store_true', dest='profiling', default=False,
        help='Adds profiling options to the build')

    parser.add_option_group(cabalOptions) 

    return


def generateCabalString(
    cfg,
    options):

    includeDirs = '.:..'
    linkDirs = ''
    linkLibs = ''

    logger = logging.getLogger('generateCabalString')

    extraLibDirs = cfg['extra-lib-dirs']

    splitDirs = options.extraLibDirs.split(':')
    if splitDirs != ['']:
        logger.info('extra-lib-dirs found on command line: %s', splitDirs)
        extraLibDirs += splitDirs

    extraLibraries = cfg['extra-libraries']

    splitDirs = options.extraLibraries.split(':')
    if splitDirs != ['']:
        logger.info('extra-libraries found on command line: %s', splitDirs)
        extraLibraries += splitDirs

    ghcOptions = options.ghcOptions

    if options.unixmode:
        logger.info('Adding option to specify binaries relative path as a place to search for shared libraries...')
        ghcOptions += ' ' + unixRPathOpt()

    if options.release:
        logger.info('Adding optimisation options for release builds...')
        ghcOptions += ' -O3'

    if options.profiling:
        logger.info('Adding profiling options for the build...')
        ghcOptions += ' -rtsopts -eventlog -threaded'

    optionStr = '-i%s %s' % (includeDirs, ghcOptions)

    result = '-- Initial testMain.cabal generated by cabal init.  For further\n\
-- documentation, see http://haskell.org/cabal/users-guide/\n\
\n\
-- The name of the package.\n\
name:                ' + cfg['name'] + '\n\
\n\
-- The package version.  See the Haskell package versioning policy (PVP)\n\
-- for standards guiding when and how versions should be incremented.\n\
-- http://www.haskell.org/haskellwiki/Package_versioning_policy\n\
-- PVP summary:      +-+------- breaking API changes\n\
--                   | | +----- non-breaking API additions\n\
--                   | | | +--- code changes with no API change\n\
version:             ' + cfg['version'] + '\n\
\n\
-- A short (one-line) description of the package.\n\
synopsis:            ' + cfg['synopsis'] + '\n\
\n\
-- A longer description of the package.\n\
-- description:         \n\
\n\
-- URL for the project homepage or repository.\n\
homepage:            ' + cfg['homepage'] + '\n\
\n\
-- The license under which the package is released.\n\
license:             ' + cfg['license'] + '\n\
\n\
-- The file containing the license text.\n\
license-file:        LICENSE\n\
\n\
-- The package author(s).\n\
author:              ' + cfg['author'] + '\n\
\n\
-- An email address to which users can send suggestions, bug reports, and \n\
-- patches.\n\
maintainer:          ' + cfg['maintainer'] + '\n\
\n\
-- A copyright notice.\n\
-- copyright:           \n\
\n\
category:            ' + cfg['category'] + '\n\
\n\
build-type:          ' + cfg['build-type'] + '\n\
\n\
-- Constraint on the version of Cabal needed to build this package.\n\
cabal-version:       >=1.8\n\
\n\
\n\
executable ' + cfg['name'] + '\n\
  -- .hs or .lhs file containing the Main module.\n\
  main-is: ' + cfg['main-is'] + '            \n\
 \n\
  ghc-options: ' + optionStr + ' \n\
  extra-libraries: ' + ', '.join(extraLibraries) + '\n\
  extra-lib-dirs: ' + ', '.join(extraLibDirs) + '\n\
  -- Modules included in this executable, other than Main.\n\
  -- other-modules:       \n\
  \n\
  -- Other library packages from which modules are imported.\n\
  build-depends:       ' + cfg['build-depends']
  
    return result

def main(options, args, parser):

    if len(args) != 2:
        parser.error(
            'Expected 2 arguments, got %d instead', 
            len(args))

    jsonConfig = args[0]
    outputPath = args[1]

    logger = logging.getLogger(__name__)

    cfg = None

    try:
        with open(jsonConfig, 'r') as jsonFile:
            cfgString = jsonFile.read()

            logger.debug('%s', cfgString)

            cfg = json.loads(cfgString)

    except IOError as fileError:
        logger.critical('Error loading JSON config: %s', fileError)
        return
    
    cabalString = generateCabalString(
        cfg,
        options)

    try:
        with open(outputPath, 'w') as outFile:
            outFile.write(cabalString)

    except IOError as fileError:
        logger.critical(
            'Failed to write to output file: %s', 
            fileError)
        return 

    return

if __name__ == '__main__':
    appUtils.main(usageString, versionString, appSetOpts, main)
